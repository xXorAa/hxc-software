<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>adf_dir.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>adf_dir.c</h1><a href="adf__dir_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> *  ADF Library. (C) 1997-2002 Laurent Clevy</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> */</span>
00010 <span class="preprocessor">#include&lt;stdlib.h&gt;</span>
00011 <span class="preprocessor">#include&lt;string.h&gt;</span>
00012 <span class="preprocessor">#include&lt;ctype.h&gt;</span>
00013 
00014 <span class="preprocessor">#include"adf_dir.h"</span>
00015 <span class="preprocessor">#include"adf_str.h"</span>
00016 <span class="preprocessor">#include"adf_util.h"</span>
00017 <span class="preprocessor">#include"defendian.h"</span>
00018 <span class="preprocessor">#include"adf_blk.h"</span>
00019 <span class="preprocessor">#include"adf_raw.h"</span>
00020 <span class="preprocessor">#include"adf_disk.h"</span>
00021 <span class="preprocessor">#include"adf_bitm.h"</span>
00022 <span class="preprocessor">#include"adf_file.h"</span>
00023 <span class="preprocessor">#include"adf_err.h"</span>
00024 <span class="preprocessor">#include"adf_cache.h"</span>
00025 
00026 <span class="keyword">extern</span> <span class="keyword">struct </span>Env adfEnv;
00027 
00028 
00029 <span class="comment">/*</span>
00030 <span class="comment"> * adfRenameEntry</span>
00031 <span class="comment"> *</span>
00032 <span class="comment"> */</span> 
00033 RETCODE adfRenameEntry(<span class="keyword">struct</span> Volume *vol, SECTNUM pSect, <span class="keywordtype">char</span> *oldName,
00034     SECTNUM nPSect, <span class="keywordtype">char</span> *newName)
00035 {
00036     <span class="keyword">struct </span>bEntryBlock parent, previous, entry, nParent;
00037     SECTNUM nSect2, nSect, prevSect, tmpSect;
00038     <span class="keywordtype">int</span> hashValueO, hashValueN, len;
00039     <span class="keywordtype">char</span> name2[MAXNAMELEN+1], name3[MAXNAMELEN+1];
00040     BOOL intl;
00041     RETCODE rc;
00042 
00043     <span class="keywordflow">if</span> (strcmp(oldName,newName)==0)
00044         <span class="keywordflow">return</span> RC_OK;
00045     
00046     intl = isINTL(vol-&gt;dosType) || isDIRCACHE(vol-&gt;dosType);
00047     len = strlen(newName);
00048     myToUpper((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)name2, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)newName, len, intl);
00049     myToUpper((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)name3, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)oldName, strlen(oldName), intl);
00050     <span class="comment">/* newName == oldName ? */</span>
00051 
00052     <span class="keywordflow">if</span> (adfReadEntryBlock( vol, pSect, &amp;parent )!=RC_OK)
00053         <span class="keywordflow">return</span> RC_ERROR;
00054 
00055     hashValueO = adfGetHashValue((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)oldName, intl);
00056 
00057     nSect = adfNameToEntryBlk(vol, parent.hashTable, oldName, &amp;entry, &amp;prevSect);
00058     <span class="keywordflow">if</span> (nSect==-1) {
00059         (*adfEnv.wFct)(<span class="stringliteral">"adfRenameEntry : existing entry not found"</span>);
00060         <span class="keywordflow">return</span> RC_ERROR;
00061     }
00062 
00063     <span class="comment">/* change name and parent dir */</span>
00064     entry.nameLen = min(31, strlen(newName));
00065     memcpy(entry.name, newName, entry.nameLen);
00066     entry.parent = nPSect;
00067     tmpSect = entry.nextSameHash;
00068 
00069     entry.nextSameHash = 0;
00070     <span class="keywordflow">if</span> (adfWriteEntryBlock(vol, nSect, &amp;entry)!=RC_OK)
00071         <span class="keywordflow">return</span> RC_ERROR;
00072 
00073     <span class="comment">/* del from the oldname list */</span>
00074 
00075     <span class="comment">/* in hashTable */</span>
00076     <span class="keywordflow">if</span> (prevSect==0) {
00077         parent.hashTable[hashValueO] = tmpSect;
00078         <span class="keywordflow">if</span> (parent.secType==ST_ROOT)
00079             rc = adfWriteRootBlock(vol, pSect, (<span class="keyword">struct</span> bRootBlock*)&amp;parent);
00080         <span class="keywordflow">else</span>
00081             rc = adfWriteDirBlock(vol, pSect, (<span class="keyword">struct</span> bDirBlock*)&amp;parent);
00082         <span class="keywordflow">if</span> (rc!=RC_OK)
00083             <span class="keywordflow">return</span> rc;
00084     }
00085     <span class="keywordflow">else</span> {
00086         <span class="comment">/* in linked list */</span>
00087         <span class="keywordflow">if</span> (adfReadEntryBlock(vol, prevSect, &amp;previous)!=RC_OK)
00088             <span class="keywordflow">return</span> RC_ERROR;
00089         <span class="comment">/* entry.nextSameHash (tmpSect) could be == 0 */</span>
00090         previous.nextSameHash = tmpSect;
00091         <span class="keywordflow">if</span> (adfWriteEntryBlock(vol, prevSect, &amp;previous)!=RC_OK)
00092             <span class="keywordflow">return</span> RC_ERROR;
00093     }
00094 
00095 
00096     <span class="keywordflow">if</span> (adfReadEntryBlock( vol, nPSect, &amp;nParent )!=RC_OK)
00097         <span class="keywordflow">return</span> RC_ERROR;
00098 
00099     hashValueN = adfGetHashValue((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)newName, intl);
00100     nSect2 = nParent.hashTable[ hashValueN ];
00101     <span class="comment">/* no list */</span>
00102     <span class="keywordflow">if</span> (nSect2==0) {
00103         nParent.hashTable[ hashValueN ] = nSect;
00104         <span class="keywordflow">if</span> (nParent.secType==ST_ROOT)
00105             rc = adfWriteRootBlock(vol, nPSect, (<span class="keyword">struct</span> bRootBlock*)&amp;nParent);
00106         <span class="keywordflow">else</span>
00107             rc = adfWriteDirBlock(vol, nPSect, (<span class="keyword">struct</span> bDirBlock*)&amp;nParent);
00108     }
00109     <span class="keywordflow">else</span> {
00110         <span class="comment">/* a list exists : addition at the end */</span>
00111         <span class="comment">/* len = strlen(newName);</span>
00112 <span class="comment">                   * name2 == newName</span>
00113 <span class="comment">                   */</span>
00114         <span class="keywordflow">do</span> {
00115             <span class="keywordflow">if</span> (adfReadEntryBlock(vol, nSect2, &amp;previous)!=RC_OK)
00116                 <span class="keywordflow">return</span> -1;
00117             <span class="keywordflow">if</span> (previous.nameLen==len) {
00118                 myToUpper((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)name3,(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)previous.name,previous.nameLen,intl);
00119                 <span class="keywordflow">if</span> (strncmp(name3,name2,len)==0) {
00120                     (*adfEnv.wFct)(<span class="stringliteral">"adfRenameEntry : entry already exists"</span>);
00121                     <span class="keywordflow">return</span> -1;
00122                 }
00123             }
00124             nSect2 = previous.nextSameHash;
00125 <span class="comment">/*printf("sect=%ld\n",nSect2);*/</span>
00126         }<span class="keywordflow">while</span>(nSect2!=0);
00127         
00128         previous.nextSameHash = nSect;
00129         <span class="keywordflow">if</span> (previous.secType==ST_DIR)
00130             rc=adfWriteDirBlock(vol, previous.headerKey, 
00131                    (<span class="keyword">struct</span> bDirBlock*)&amp;previous);
00132         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (previous.secType==ST_FILE)
00133             rc=adfWriteFileHdrBlock(vol, previous.headerKey, 
00134                    (<span class="keyword">struct</span> bFileHeaderBlock*)&amp;previous);
00135         <span class="keywordflow">else</span> {
00136             (*adfEnv.wFct)(<span class="stringliteral">"adfRenameEntry : unknown entry type"</span>);
00137             rc = RC_ERROR;
00138         }
00139     
00140     }
00141     <span class="keywordflow">if</span> (rc!=RC_OK)
00142         <span class="keywordflow">return</span> rc;
00143 
00144     <span class="keywordflow">if</span> (isDIRCACHE(vol-&gt;dosType)) {
00145         <span class="keywordflow">if</span> (pSect==nPSect) {
00146             adfUpdateCache(vol, &amp;parent, (<span class="keyword">struct</span> bEntryBlock*)&amp;entry,TRUE);
00147         }
00148         <span class="keywordflow">else</span> {
00149             adfDelFromCache(vol,&amp;parent,entry.headerKey);
00150             adfAddInCache(vol,&amp;nParent,&amp;entry);
00151         }
00152     }
00153 <span class="comment">/*</span>
00154 <span class="comment">    if (isDIRCACHE(vol-&gt;dosType) &amp;&amp; pSect!=nPSect) {</span>
00155 <span class="comment">        adfUpdateCache(vol, &amp;nParent, (struct bEntryBlock*)&amp;entry,TRUE);</span>
00156 <span class="comment">    }</span>
00157 <span class="comment">*/</span>
00158     <span class="keywordflow">return</span> RC_OK;
00159 }
00160 
00161 <span class="comment">/*</span>
00162 <span class="comment"> * adfRemoveEntry</span>
00163 <span class="comment"> *</span>
00164 <span class="comment"> */</span>
00165 RETCODE adfRemoveEntry(<span class="keyword">struct</span> Volume *vol, SECTNUM pSect, <span class="keywordtype">char</span> *name)
00166 {
00167     <span class="keyword">struct </span>bEntryBlock parent, previous, entry;
00168     SECTNUM nSect2, nSect;
00169     <span class="keywordtype">int</span> hashVal;
00170     BOOL intl;
00171 
00172     <span class="keywordflow">if</span> (adfReadEntryBlock( vol, pSect, &amp;parent )!=RC_OK)
00173         <span class="keywordflow">return</span> RC_ERROR;
00174     nSect = adfNameToEntryBlk(vol, parent.hashTable, name, &amp;entry, &amp;nSect2);
00175     <span class="keywordflow">if</span> (nSect==-1) {
00176         (*adfEnv.wFct)(<span class="stringliteral">"adfRemoveEntry : entry not found"</span>);
00177         <span class="keywordflow">return</span> RC_ERROR;
00178     }
00179     <span class="comment">/* if it is a directory, is it empty ? */</span>
00180     <span class="keywordflow">if</span> ( entry.secType==ST_DIR &amp;&amp; !isDirEmpty((<span class="keyword">struct</span> bDirBlock*)&amp;entry) ) {
00181         (*adfEnv.wFct)(<span class="stringliteral">"adfRemoveEntry : directory not empty"</span>);
00182         <span class="keywordflow">return</span> RC_ERROR;
00183     }
00184 <span class="comment">/*    printf("name=%s  nSect2=%ld\n",name, nSect2);*/</span>
00185 
00186     <span class="comment">/* in parent hashTable */</span>
00187     <span class="keywordflow">if</span> (nSect2==0) {
00188         intl = isINTL(vol-&gt;dosType) || isDIRCACHE(vol-&gt;dosType);
00189         hashVal = adfGetHashValue( (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)name, intl );
00190 <span class="comment">/*printf("hashTable=%d nexthash=%d\n",parent.hashTable[hashVal],</span>
00191 <span class="comment"> entry.nextSameHash);*/</span>
00192         parent.hashTable[hashVal] = entry.nextSameHash;
00193         <span class="keywordflow">if</span> (adfWriteEntryBlock(vol, pSect, &amp;parent)!=RC_OK)
00194             <span class="keywordflow">return</span> RC_ERROR;
00195     }
00196     <span class="comment">/* in linked list */</span>
00197     <span class="keywordflow">else</span> {
00198         <span class="keywordflow">if</span> (adfReadEntryBlock(vol, nSect2, &amp;previous)!=RC_OK)
00199             <span class="keywordflow">return</span> RC_ERROR;
00200         previous.nextSameHash = entry.nextSameHash;
00201         <span class="keywordflow">if</span> (adfWriteEntryBlock(vol, nSect2, &amp;previous)!=RC_OK)
00202             <span class="keywordflow">return</span> RC_ERROR;
00203     }
00204 
00205     <span class="keywordflow">if</span> (entry.secType==ST_FILE) {
00206         adfFreeFileBlocks(vol, (<span class="keyword">struct</span> bFileHeaderBlock*)&amp;entry);
00207         <span class="keywordflow">if</span> (adfEnv.useNotify)
00208              (*adfEnv.notifyFct)(pSect,ST_FILE);
00209     }
00210     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (entry.secType==ST_DIR) {
00211         adfSetBlockFree(vol, nSect);
00212         <span class="comment">/* free dir cache block : the directory must be empty, so there's only one cache block */</span>
00213         <span class="keywordflow">if</span> (isDIRCACHE(vol-&gt;dosType))
00214             adfSetBlockFree(vol, entry.extension);
00215         <span class="keywordflow">if</span> (adfEnv.useNotify)
00216             (*adfEnv.notifyFct)(pSect,ST_DIR);
00217     }
00218     <span class="keywordflow">else</span> {
00219         (*adfEnv.wFct)(<span class="stringliteral">"adfRemoveEntry : secType not supported"</span>);
00220         <span class="keywordflow">return</span> RC_ERROR;
00221     }
00222 
00223     <span class="keywordflow">if</span> (isDIRCACHE(vol-&gt;dosType))
00224         adfDelFromCache(vol, &amp;parent, entry.headerKey);
00225 
00226     adfUpdateBitmap(vol);
00227 
00228     <span class="keywordflow">return</span> RC_OK;
00229 }
00230 
00231 
00232 <span class="comment">/*</span>
00233 <span class="comment"> * adfSetEntryComment</span>
00234 <span class="comment"> *</span>
00235 <span class="comment"> */</span>
00236 RETCODE adfSetEntryComment(<span class="keyword">struct</span> Volume* vol, SECTNUM parSect, <span class="keywordtype">char</span>* name,
00237     <span class="keywordtype">char</span>* newCmt)
00238 {
00239     <span class="keyword">struct </span>bEntryBlock parent, entry;
00240     SECTNUM nSect;
00241 
00242     <span class="keywordflow">if</span> (adfReadEntryBlock( vol, parSect, &amp;parent )!=RC_OK)
00243         <span class="keywordflow">return</span> RC_ERROR;
00244     nSect = adfNameToEntryBlk(vol, parent.hashTable, name, &amp;entry, NULL);
00245     <span class="keywordflow">if</span> (nSect==-1) {
00246         (*adfEnv.wFct)(<span class="stringliteral">"adfSetEntryComment : entry not found"</span>);
00247         <span class="keywordflow">return</span> RC_ERROR;
00248     }
00249 
00250     entry.commLen = min(MAXCMMTLEN, strlen(newCmt));
00251     memcpy(entry.comment, newCmt, entry.commLen);
00252 
00253     <span class="keywordflow">if</span> (entry.secType==ST_DIR)
00254         adfWriteDirBlock(vol, nSect, (<span class="keyword">struct</span> bDirBlock*)&amp;entry);
00255     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (entry.secType==ST_FILE)
00256         adfWriteFileHdrBlock(vol, nSect, (<span class="keyword">struct</span> bFileHeaderBlock*)&amp;entry);
00257     <span class="keywordflow">else</span>
00258         (*adfEnv.wFct)(<span class="stringliteral">"adfSetEntryComment : entry secType incorrect"</span>);
00259 
00260     <span class="keywordflow">if</span> (isDIRCACHE(vol-&gt;dosType))
00261         adfUpdateCache(vol, &amp;parent, (<span class="keyword">struct</span> bEntryBlock*)&amp;entry, TRUE);
00262 
00263     <span class="keywordflow">return</span> RC_OK;
00264 }
00265 
00266 
00267 <span class="comment">/*</span>
00268 <span class="comment"> * adfSetEntryAccess</span>
00269 <span class="comment"> *</span>
00270 <span class="comment"> */</span>
00271 RETCODE adfSetEntryAccess(<span class="keyword">struct</span> Volume* vol, SECTNUM parSect, <span class="keywordtype">char</span>* name,
00272     <span class="keywordtype">long</span> newAcc)
00273 {
00274     <span class="keyword">struct </span>bEntryBlock parent, entry;
00275     SECTNUM nSect;
00276 
00277     <span class="keywordflow">if</span> (adfReadEntryBlock( vol, parSect, &amp;parent )!=RC_OK)
00278         <span class="keywordflow">return</span> RC_ERROR;
00279     nSect = adfNameToEntryBlk(vol, parent.hashTable, name, &amp;entry, NULL);
00280     <span class="keywordflow">if</span> (nSect==-1) {
00281         (*adfEnv.wFct)(<span class="stringliteral">"adfSetEntryAccess : entry not found"</span>);
00282         <span class="keywordflow">return</span> RC_ERROR;
00283     }
00284 
00285     entry.access = newAcc;
00286     <span class="keywordflow">if</span> (entry.secType==ST_DIR)
00287         adfWriteDirBlock(vol, nSect, (<span class="keyword">struct</span> bDirBlock*)&amp;entry);
00288     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (entry.secType==ST_FILE)
00289         adfWriteFileHdrBlock(vol, nSect, (<span class="keyword">struct</span> bFileHeaderBlock*)&amp;entry);
00290     <span class="keywordflow">else</span>
00291         (*adfEnv.wFct)(<span class="stringliteral">"adfSetEntryAccess : entry secType incorrect"</span>);
00292 
00293     <span class="keywordflow">if</span> (isDIRCACHE(vol-&gt;dosType))
00294         adfUpdateCache(vol, &amp;parent, (<span class="keyword">struct</span> bEntryBlock*)&amp;entry, FALSE);
00295 
00296     <span class="keywordflow">return</span> RC_OK;
00297 }
00298 
00299 
00300 <span class="comment">/*</span>
00301 <span class="comment"> * isDirEmpty</span>
00302 <span class="comment"> *</span>
00303 <span class="comment"> */</span>
00304 BOOL isDirEmpty(<span class="keyword">struct</span> bDirBlock *dir)
00305 {
00306     <span class="keywordtype">int</span> i;
00307     
00308     <span class="keywordflow">for</span>(i=0; i&lt;HT_SIZE; i++)
00309         <span class="keywordflow">if</span> (dir-&gt;hashTable[i]!=0)
00310            <span class="keywordflow">return</span> FALSE;
00311 
00312     <span class="keywordflow">return</span> TRUE;
00313 }
00314 
00315 
00316 <span class="comment">/*</span>
00317 <span class="comment"> * adfFreeDirList</span>
00318 <span class="comment"> *</span>
00319 <span class="comment"> */</span>
00320 <span class="keywordtype">void</span> adfFreeDirList(<span class="keyword">struct</span> List* list)
00321 {
00322     <span class="keyword">struct </span>List *root, *cell;
00323 
00324     root = cell = list;
00325     <span class="keywordflow">while</span>(cell!=NULL) {
00326         adfFreeEntry(cell-&gt;content);
00327         <span class="keywordflow">if</span> (cell-&gt;subdir!=NULL)
00328             adfFreeDirList(cell-&gt;subdir);
00329         cell = cell-&gt;next;
00330     }
00331     freeList(root);
00332 }
00333 
00334 
00335 <span class="comment">/*</span>
00336 <span class="comment"> * adfGetRDirEnt</span>
00337 <span class="comment"> *</span>
00338 <span class="comment"> */</span>
00339 <span class="keyword">struct </span>List* adfGetRDirEnt(struct Volume* vol, SECTNUM nSect, BOOL recurs )
00340 {
00341     <span class="keyword">struct </span>bEntryBlock entryBlk;
00342     <span class="keyword">struct </span>List *cell, *head;
00343     <span class="keywordtype">int</span> i;
00344     <span class="keyword">struct </span>Entry *entry;
00345     SECTNUM nextSector;
00346     <span class="keywordtype">long</span> *hashTable;
00347     <span class="keyword">struct </span>bEntryBlock parent;
00348 
00349 
00350     <span class="keywordflow">if</span> (adfEnv.useDirCache &amp;&amp; isDIRCACHE(vol-&gt;dosType))
00351         <span class="keywordflow">return</span> (adfGetDirEntCache(vol, nSect, recurs ));
00352 
00353 
00354     <span class="keywordflow">if</span> (adfReadEntryBlock(vol,nSect,&amp;parent)!=RC_OK)
00355         <span class="keywordflow">return</span> NULL;
00356 
00357     hashTable = parent.hashTable;
00358     cell = head = NULL;
00359     <span class="keywordflow">for</span>(i=0; i&lt;HT_SIZE; i++) {
00360         <span class="keywordflow">if</span> (hashTable[i]!=0) {
00361              entry = (<span class="keyword">struct </span>Entry *)malloc(sizeof(struct Entry));
00362              <span class="keywordflow">if</span> (!entry) {
00363                  adfFreeDirList(head);
00364                  (*adfEnv.eFct)(<span class="stringliteral">"adfGetDirEnt : malloc"</span>);
00365                  <span class="keywordflow">return</span> NULL;
00366              }
00367              <span class="keywordflow">if</span> (adfReadEntryBlock(vol, hashTable[i], &amp;entryBlk)!=RC_OK) {
00368                  adfFreeDirList(head);
00369                  <span class="keywordflow">return</span> NULL;
00370              }
00371              <span class="keywordflow">if</span> (adfEntBlock2Entry(&amp;entryBlk, entry)!=RC_OK) {
00372                  adfFreeDirList(head); <span class="keywordflow">return</span> NULL;
00373              }
00374              entry-&gt;sector = hashTable[i];
00375     
00376              <span class="keywordflow">if</span> (head==NULL)
00377                  head = cell = newCell(0, (<span class="keywordtype">void</span>*)entry);
00378              <span class="keywordflow">else</span>
00379                  cell = newCell(cell, (<span class="keywordtype">void</span>*)entry);
00380              <span class="keywordflow">if</span> (cell==NULL) {
00381                  adfFreeDirList(head); <span class="keywordflow">return</span> NULL;
00382              }
00383 
00384              <span class="keywordflow">if</span> (recurs &amp;&amp; entry-&gt;type==ST_DIR)
00385                  cell-&gt;subdir = adfGetRDirEnt(vol,entry-&gt;sector,recurs);
00386 
00387              <span class="comment">/* same hashcode linked list */</span>
00388              nextSector = entryBlk.nextSameHash;
00389              <span class="keywordflow">while</span>( nextSector!=0 ) {
00390                  entry = (<span class="keyword">struct </span>Entry *)malloc(sizeof(struct Entry));
00391                  <span class="keywordflow">if</span> (!entry) {
00392                      adfFreeDirList(head);
00393                      (*adfEnv.eFct)(<span class="stringliteral">"adfGetDirEnt : malloc"</span>);
00394                      <span class="keywordflow">return</span> NULL;
00395                  }
00396                  <span class="keywordflow">if</span> (adfReadEntryBlock(vol, nextSector, &amp;entryBlk)!=RC_OK) {
00397                      adfFreeDirList(head); <span class="keywordflow">return</span> NULL;
00398                  }
00399 
00400                  <span class="keywordflow">if</span> (adfEntBlock2Entry(&amp;entryBlk, entry)!=RC_OK) {
00401                      adfFreeDirList(head);
00402                      <span class="keywordflow">return</span> NULL;
00403                  }
00404                  entry-&gt;sector = nextSector;
00405     
00406                  cell = newCell(cell, (<span class="keywordtype">void</span>*)entry);
00407                  <span class="keywordflow">if</span> (cell==NULL) {
00408                      adfFreeDirList(head); <span class="keywordflow">return</span> NULL;
00409                  }
00410                  
00411                  <span class="keywordflow">if</span> (recurs &amp;&amp; entry-&gt;type==ST_DIR)
00412                      cell-&gt;subdir = adfGetRDirEnt(vol,entry-&gt;sector,recurs);
00413                  
00414                  nextSector = entryBlk.nextSameHash;
00415              }
00416         }
00417     }
00418 
00419 <span class="comment">/*    if (parent.extension &amp;&amp; isDIRCACHE(vol-&gt;dosType) )</span>
00420 <span class="comment">        adfReadDirCache(vol,parent.extension);</span>
00421 <span class="comment">*/</span>
00422     <span class="keywordflow">return</span> head;
00423 }
00424 
00425 
00426 <span class="comment">/*</span>
00427 <span class="comment"> * adfGetDirEnt</span>
00428 <span class="comment"> *</span>
00429 <span class="comment"> */</span>
00430 <span class="keyword">struct </span>List* adfGetDirEnt(struct Volume* vol, SECTNUM nSect )
00431 {
00432     <span class="keywordflow">return</span> adfGetRDirEnt(vol, nSect, FALSE);
00433 }
00434 
00435 
00436 <span class="comment">/*</span>
00437 <span class="comment"> * adfFreeEntry</span>
00438 <span class="comment"> *</span>
00439 <span class="comment"> */</span>
00440 <span class="keywordtype">void</span> adfFreeEntry(<span class="keyword">struct</span> Entry *entry)
00441 {
00442     <span class="keywordflow">if</span> (entry==NULL)
00443        <span class="keywordflow">return</span>;
00444     <span class="keywordflow">if</span> (entry-&gt;name)
00445         free(entry-&gt;name);
00446     <span class="keywordflow">if</span> (entry-&gt;comment)
00447         free(entry-&gt;comment);
00448     free(entry);    
00449 }
00450 
00451 
00452 <span class="comment">/*</span>
00453 <span class="comment"> * adfToRootDir</span>
00454 <span class="comment"> *</span>
00455 <span class="comment"> */</span>
00456 RETCODE adfToRootDir(<span class="keyword">struct</span> Volume *vol)
00457 {
00458     vol-&gt;curDirPtr = vol-&gt;rootBlock;
00459 
00460     <span class="keywordflow">return</span> RC_OK;
00461 }
00462 
00463 
00464 <span class="comment">/*</span>
00465 <span class="comment"> * adfChangeDir</span>
00466 <span class="comment"> *</span>
00467 <span class="comment"> */</span>
00468 RETCODE adfChangeDir(<span class="keyword">struct</span> Volume* vol, <span class="keywordtype">char</span> *name)
00469 {
00470     <span class="keyword">struct </span>bEntryBlock entry;
00471     SECTNUM nSect;
00472 
00473     <span class="keywordflow">if</span> (adfReadEntryBlock( vol, vol-&gt;curDirPtr, &amp;entry )!=RC_OK)
00474         <span class="keywordflow">return</span> RC_ERROR;
00475     nSect = adfNameToEntryBlk(vol, entry.hashTable, name, &amp;entry, NULL);
00476 <span class="comment">/*printf("adfChangeDir=%d\n",nSect);*/</span>
00477     <span class="keywordflow">if</span> (nSect!=-1) {
00478         vol-&gt;curDirPtr = nSect;
00479 <span class="comment">/*        if (*adfEnv.useNotify)</span>
00480 <span class="comment">            (*adfEnv.notifyFct)(0,ST_ROOT);*/</span>
00481         <span class="keywordflow">return</span> RC_OK;
00482     }
00483     <span class="keywordflow">else</span>
00484         <span class="keywordflow">return</span> RC_ERROR;
00485 }
00486 
00487 
00488 <span class="comment">/*</span>
00489 <span class="comment"> * adfParentDir</span>
00490 <span class="comment"> *</span>
00491 <span class="comment"> */</span>
00492 SECTNUM adfParentDir(<span class="keyword">struct</span> Volume* vol)
00493 {
00494     <span class="keyword">struct </span>bEntryBlock entry;
00495 
00496     <span class="keywordflow">if</span> (vol-&gt;curDirPtr!=vol-&gt;rootBlock) {
00497         <span class="keywordflow">if</span> (adfReadEntryBlock( vol, vol-&gt;curDirPtr, &amp;entry )!=RC_OK)
00498             <span class="keywordflow">return</span> RC_ERROR;
00499         vol-&gt;curDirPtr = entry.parent;
00500     }
00501     <span class="keywordflow">return</span> RC_OK;
00502 }
00503 
00504 
00505 <span class="comment">/*</span>
00506 <span class="comment"> * adfEntBlock2Entry</span>
00507 <span class="comment"> *</span>
00508 <span class="comment"> */</span>
00509 RETCODE adfEntBlock2Entry(<span class="keyword">struct</span> bEntryBlock *entryBlk, <span class="keyword">struct</span> Entry *entry)
00510 {
00511     <span class="keywordtype">char</span> buf[MAXCMMTLEN+1];
00512     <span class="keywordtype">int</span> len;
00513 
00514     entry-&gt;type = entryBlk-&gt;secType;
00515     entry-&gt;parent = entryBlk-&gt;parent;
00516 
00517     len = min(entryBlk-&gt;nameLen, MAXNAMELEN);
00518     strncpy(buf, entryBlk-&gt;name, len);
00519     buf[len] = <span class="charliteral">'\0'</span>;
00520     entry-&gt;name = strdup(buf);
00521     <span class="keywordflow">if</span> (entry-&gt;name==NULL)
00522         <span class="keywordflow">return</span> RC_MALLOC;
00523 <span class="comment">/*printf("len=%d name=%s parent=%ld\n",entryBlk-&gt;nameLen, entry-&gt;name,entry-&gt;parent );*/</span>
00524     adfDays2Date( entryBlk-&gt;days, &amp;(entry-&gt;year), &amp;(entry-&gt;month), &amp;(entry-&gt;days));
00525     entry-&gt;hour = entryBlk-&gt;mins/60;
00526     entry-&gt;mins = entryBlk-&gt;mins%60;
00527     entry-&gt;secs = entryBlk-&gt;ticks/50;
00528 
00529     entry-&gt;access = -1;
00530     entry-&gt;size = 0L;
00531     entry-&gt;comment = NULL;
00532     entry-&gt;real = 0L;
00533     <span class="keywordflow">switch</span>(entryBlk-&gt;secType) {
00534     <span class="keywordflow">case</span> ST_ROOT:
00535         <span class="keywordflow">break</span>;
00536     <span class="keywordflow">case</span> ST_DIR:
00537         entry-&gt;access = entryBlk-&gt;access;
00538         len = min(entryBlk-&gt;commLen, MAXCMMTLEN);
00539         strncpy(buf, entryBlk-&gt;comment, len);
00540         buf[len] = <span class="charliteral">'\0'</span>;
00541         entry-&gt;comment = strdup(buf);
00542         <span class="keywordflow">if</span> (entry-&gt;comment==NULL) {
00543             free(entry-&gt;name);
00544             <span class="keywordflow">return</span> RC_MALLOC;
00545         }
00546         <span class="keywordflow">break</span>;
00547     <span class="keywordflow">case</span> ST_FILE:
00548         entry-&gt;access = entryBlk-&gt;access;
00549         entry-&gt;size = entryBlk-&gt;byteSize;
00550         len = min(entryBlk-&gt;commLen, MAXCMMTLEN);
00551         strncpy(buf, entryBlk-&gt;comment, len);
00552         buf[len] = <span class="charliteral">'\0'</span>;
00553         entry-&gt;comment = strdup(buf);
00554         <span class="keywordflow">if</span> (entry-&gt;comment==NULL) {
00555             free(entry-&gt;name);
00556             <span class="keywordflow">return</span> RC_MALLOC;
00557         }
00558         <span class="keywordflow">break</span>;
00559     <span class="keywordflow">case</span> ST_LFILE:
00560     <span class="keywordflow">case</span> ST_LDIR:
00561         entry-&gt;real = entryBlk-&gt;realEntry;
00562     <span class="keywordflow">case</span> ST_LSOFT:
00563         <span class="keywordflow">break</span>;
00564     <span class="keywordflow">default</span>:
00565         (*adfEnv.wFct)(<span class="stringliteral">"unknown entry type"</span>);
00566     }
00567     
00568     <span class="keywordflow">return</span> RC_OK;
00569 }
00570 
00571 
00572 <span class="comment">/*</span>
00573 <span class="comment"> * adfNameToEntryBlk</span>
00574 <span class="comment"> *</span>
00575 <span class="comment"> */</span>
00576 SECTNUM adfNameToEntryBlk(<span class="keyword">struct</span> Volume *vol, <span class="keywordtype">long</span> ht[], <span class="keywordtype">char</span>* name, 
00577     <span class="keyword">struct</span> bEntryBlock *entry, SECTNUM *nUpdSect)
00578 {
00579     <span class="keywordtype">int</span> hashVal;
00580     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> upperName[MAXNAMELEN+1];
00581     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> upperName2[MAXNAMELEN+1];
00582     SECTNUM nSect;
00583     <span class="keywordtype">int</span> nameLen;
00584     BOOL found;
00585     SECTNUM updSect;
00586     BOOL intl;
00587 
00588     intl = isINTL(vol-&gt;dosType) || isDIRCACHE(vol-&gt;dosType);
00589     hashVal = adfGetHashValue( (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)name, intl );
00590     nameLen = strlen(name);
00591     myToUpper( upperName, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)name, nameLen, intl );
00592 
00593     nSect = ht[hashVal];
00594 <span class="comment">/*printf("name=%s ht[%d]=%d upper=%s len=%d\n",name,hashVal,nSect,upperName,nameLen);</span>
00595 <span class="comment">printf("hashVal=%d\n",adfGetHashValue(upperName, intl ));</span>
00596 <span class="comment">if (!strcmp("españa.country",name)) {</span>
00597 <span class="comment">int i;</span>
00598 <span class="comment">for(i=0; i&lt;HT_SIZE; i++) printf("ht[%d]=%d    ",i,ht[i]);</span>
00599 <span class="comment">}*/</span>
00600     <span class="keywordflow">if</span> (nSect==0)
00601         <span class="keywordflow">return</span> -1;
00602 
00603     updSect = 0;
00604     found = FALSE;
00605     <span class="keywordflow">do</span> {
00606         <span class="keywordflow">if</span> (adfReadEntryBlock(vol, nSect, entry)!=RC_OK)
00607             <span class="keywordflow">return</span> -1;
00608         <span class="keywordflow">if</span> (nameLen==entry-&gt;nameLen) {
00609             myToUpper( upperName2, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)entry-&gt;name, nameLen, intl );
00610 <span class="comment">/*printf("2=%s %s\n",upperName2,upperName);*/</span>
00611             found = strncmp(upperName, upperName2, nameLen)==0;
00612         }
00613         <span class="keywordflow">if</span> (!found) {
00614             updSect = nSect;
00615             nSect = entry-&gt;nextSameHash; 
00616         }
00617     }<span class="keywordflow">while</span>( !found &amp;&amp; nSect!=0 );
00618 
00619     <span class="keywordflow">if</span> ( nSect==0 &amp;&amp; !found )
00620         <span class="keywordflow">return</span> -1;
00621     <span class="keywordflow">else</span> {
00622         <span class="keywordflow">if</span> (nUpdSect!=NULL)
00623             *nUpdSect = updSect;
00624         <span class="keywordflow">return</span> nSect;
00625     }
00626 }
00627 
00628 
00629 <span class="comment">/*</span>
00630 <span class="comment"> * Access2String</span>
00631 <span class="comment"> *</span>
00632 <span class="comment"> */</span>
00633     <span class="keywordtype">char</span>* 
00634 adfAccess2String(<span class="keywordtype">long</span> acc)
00635 {
00636     <span class="keyword">static</span> <span class="keywordtype">char</span> ret[8+1];
00637 
00638     strcpy(ret,<span class="stringliteral">"----rwed"</span>);
00639     <span class="keywordflow">if</span> (hasD(acc)) ret[7]=<span class="charliteral">'-'</span>;
00640     <span class="keywordflow">if</span> (hasE(acc)) ret[6]=<span class="charliteral">'-'</span>;
00641     <span class="keywordflow">if</span> (hasW(acc)) ret[5]=<span class="charliteral">'-'</span>;
00642     <span class="keywordflow">if</span> (hasR(acc)) ret[4]=<span class="charliteral">'-'</span>;
00643     <span class="keywordflow">if</span> (hasA(acc)) ret[3]=<span class="charliteral">'a'</span>;
00644     <span class="keywordflow">if</span> (hasP(acc)) ret[2]=<span class="charliteral">'p'</span>;
00645     <span class="keywordflow">if</span> (hasS(acc)) ret[1]=<span class="charliteral">'s'</span>;
00646     <span class="keywordflow">if</span> (hasH(acc)) ret[0]=<span class="charliteral">'h'</span>;
00647 
00648     <span class="keywordflow">return</span>(ret);
00649 }
00650 
00651 
00652 <span class="comment">/*</span>
00653 <span class="comment"> * adfCreateEntry</span>
00654 <span class="comment"> *</span>
00655 <span class="comment"> * if 'thisSect'==-1, allocate a sector, and insert its pointer into the hashTable of 'dir', using the </span>
00656 <span class="comment"> * name 'name'. if 'thisSect'!=-1, insert this sector pointer  into the hashTable </span>
00657 <span class="comment"> * (here 'thisSect' must be allocated before in the bitmap).</span>
00658 <span class="comment"> */</span>
00659 SECTNUM adfCreateEntry(<span class="keyword">struct</span> Volume *vol, <span class="keyword">struct</span> bEntryBlock *dir, <span class="keywordtype">char</span> *name,
00660     SECTNUM thisSect )
00661 {
00662     BOOL intl;
00663     <span class="keyword">struct </span>bEntryBlock updEntry;
00664     <span class="keywordtype">int</span> len, hashValue;
00665     RETCODE rc;
00666     <span class="keywordtype">char</span> name2[MAXNAMELEN+1], name3[MAXNAMELEN+1];
00667     SECTNUM nSect, newSect, newSect2;
00668     <span class="keyword">struct </span>bRootBlock* root;
00669 
00670 <span class="comment">/*puts("adfCreateEntry in");*/</span>
00671 
00672     intl = isINTL(vol-&gt;dosType) || isDIRCACHE(vol-&gt;dosType);
00673     len = strlen(name);
00674     myToUpper((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)name2, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)name, len, intl);
00675     hashValue = adfGetHashValue((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)name, intl);
00676     nSect = dir-&gt;hashTable[ hashValue ];
00677 
00678     <span class="keywordflow">if</span> ( nSect==0 ) {
00679         <span class="keywordflow">if</span> (thisSect!=-1)
00680             newSect = thisSect;
00681         <span class="keywordflow">else</span> {
00682             newSect = adfGet1FreeBlock(vol);
00683             <span class="keywordflow">if</span> (newSect==-1) {
00684                (*adfEnv.wFct)(<span class="stringliteral">"adfCreateEntry : nSect==-1"</span>);
00685                <span class="keywordflow">return</span> -1;
00686             }
00687         }
00688 
00689         dir-&gt;hashTable[ hashValue ] = newSect;
00690         <span class="keywordflow">if</span> (dir-&gt;secType==ST_ROOT) {
00691             root = (<span class="keyword">struct </span>bRootBlock*)dir;
00692             adfTime2AmigaTime(adfGiveCurrentTime(),
00693                 &amp;(root-&gt;cDays),&amp;(root-&gt;cMins),&amp;(root-&gt;cTicks));
00694             rc=adfWriteRootBlock(vol, vol-&gt;rootBlock, root);
00695         }
00696         <span class="keywordflow">else</span> {
00697             adfTime2AmigaTime(adfGiveCurrentTime(),&amp;(dir-&gt;days),&amp;(dir-&gt;mins),&amp;(dir-&gt;ticks));
00698             rc=adfWriteDirBlock(vol, dir-&gt;headerKey, (<span class="keyword">struct</span> bDirBlock*)dir);
00699         }
00700 <span class="comment">/*puts("adfCreateEntry out, dir");*/</span>
00701         <span class="keywordflow">if</span> (rc!=RC_OK) {
00702             adfSetBlockFree(vol, newSect);    
00703             <span class="keywordflow">return</span> -1;
00704         }
00705         <span class="keywordflow">else</span>
00706             <span class="keywordflow">return</span>( newSect );
00707     }
00708 
00709     <span class="keywordflow">do</span> {
00710         <span class="keywordflow">if</span> (adfReadEntryBlock(vol, nSect, &amp;updEntry)!=RC_OK)
00711             <span class="keywordflow">return</span> -1;
00712         <span class="keywordflow">if</span> (updEntry.nameLen==len) {
00713             myToUpper((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)name3,(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)updEntry.name,updEntry.nameLen,intl);
00714             <span class="keywordflow">if</span> (strncmp(name3,name2,len)==0) {
00715                 (*adfEnv.wFct)(<span class="stringliteral">"adfCreateEntry : entry already exists"</span>);
00716                 <span class="keywordflow">return</span> -1;
00717             }
00718         }
00719         nSect = updEntry.nextSameHash;
00720     }<span class="keywordflow">while</span>(nSect!=0);
00721 
00722     <span class="keywordflow">if</span> (thisSect!=-1)
00723         newSect2 = thisSect;
00724     <span class="keywordflow">else</span> {
00725         newSect2 = adfGet1FreeBlock(vol);
00726         <span class="keywordflow">if</span> (newSect2==-1) {
00727             (*adfEnv.wFct)(<span class="stringliteral">"adfCreateEntry : nSect==-1"</span>);
00728             <span class="keywordflow">return</span> -1;
00729         }
00730     }
00731      
00732     rc = RC_OK;
00733     updEntry.nextSameHash = newSect2;
00734     <span class="keywordflow">if</span> (updEntry.secType==ST_DIR)
00735         rc=adfWriteDirBlock(vol, updEntry.headerKey, (<span class="keyword">struct</span> bDirBlock*)&amp;updEntry);
00736     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (updEntry.secType==ST_FILE)
00737         rc=adfWriteFileHdrBlock(vol, updEntry.headerKey, 
00738             (<span class="keyword">struct</span> bFileHeaderBlock*)&amp;updEntry);
00739     <span class="keywordflow">else</span>
00740         (*adfEnv.wFct)(<span class="stringliteral">"adfCreateEntry : unknown entry type"</span>);
00741 
00742 <span class="comment">/*puts("adfCreateEntry out, hash");*/</span>
00743     <span class="keywordflow">if</span> (rc!=RC_OK) {
00744         adfSetBlockFree(vol, newSect2);    
00745         <span class="keywordflow">return</span> -1;
00746     }
00747     <span class="keywordflow">else</span>
00748         <span class="keywordflow">return</span>(newSect2);
00749 }
00750 
00751 
00752 
00753 
00754 <span class="comment">/*</span>
00755 <span class="comment"> * adfIntlToUpper</span>
00756 <span class="comment"> *</span>
00757 <span class="comment"> */</span>
00758     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>
00759 adfIntlToUpper(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c)
00760 {
00761 <span class="keywordflow">return</span> (c&gt;=<span class="charliteral">'a'</span> &amp;&amp; c&lt;='z') || (c&gt;=224 &amp;&amp; c&lt;=254 &amp;&amp; c!=247) ? c - (<span class="charliteral">'a'</span>-<span class="charliteral">'A'</span>) : c ;
00762 }
00763 
00764     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>
00765 adfToUpper(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c)
00766 {
00767 <span class="keywordflow">return</span> (c&gt;=<span class="charliteral">'a'</span> &amp;&amp; c&lt;=<span class="charliteral">'z'</span>) ? c - (<span class="charliteral">'a'</span>-<span class="charliteral">'A'</span>) : c ;
00768 }
00769 
00770 <span class="comment">/*</span>
00771 <span class="comment"> * myToUpper</span>
00772 <span class="comment"> *</span>
00773 <span class="comment"> */</span>
00774     <span class="keywordtype">void</span>
00775 myToUpper( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *nstr, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *ostr, <span class="keywordtype">int</span> nlen, BOOL intl )
00776 {
00777     <span class="keywordtype">int</span> i;
00778 
00779     <span class="keywordflow">if</span> (intl)
00780         <span class="keywordflow">for</span>(i=0; i&lt;nlen; i++)
00781             nstr[i]=adfIntlToUpper(ostr[i]);
00782     <span class="keywordflow">else</span>
00783         <span class="keywordflow">for</span>(i=0; i&lt;nlen; i++)
00784             nstr[i]=adfToUpper(ostr[i]);
00785     nstr[nlen]=<span class="charliteral">'\0'</span>;
00786 }
00787 
00788 
00789 <span class="comment">/*</span>
00790 <span class="comment"> * adfGetHashValue</span>
00791 <span class="comment"> * </span>
00792 <span class="comment"> */</span>
00793     <span class="keywordtype">int</span> 
00794 adfGetHashValue(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *name, BOOL intl)
00795 {
00796     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> hash, len;
00797     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00798     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> upper;
00799 
00800     len = hash = strlen((<span class="keywordtype">char</span>*)name);
00801     <span class="keywordflow">for</span>(i=0; i&lt;len; i++) {
00802         <span class="keywordflow">if</span> (intl)
00803             upper = adfIntlToUpper(name[i]);
00804         <span class="keywordflow">else</span>
00805             upper = toupper(name[i]);
00806         hash = (hash * 13 + upper) &amp; 0x7ff;
00807     }
00808     hash = hash % HT_SIZE;
00809 
00810     <span class="keywordflow">return</span>(hash);
00811 }
00812 
00813 
00814 <span class="comment">/*</span>
00815 <span class="comment"> * printEntry</span>
00816 <span class="comment"> *</span>
00817 <span class="comment"> */</span>
00818 <span class="keywordtype">void</span> printEntry(<span class="keyword">struct</span> Entry* entry)
00819 {
00820     printf(<span class="stringliteral">"%-30s %2d %6ld "</span>, entry-&gt;name, entry-&gt;type, entry-&gt;sector);
00821     printf(<span class="stringliteral">"%2d/%02d/%04d %2d:%02d:%02d"</span>,entry-&gt;days, entry-&gt;month, entry-&gt;year,
00822         entry-&gt;hour, entry-&gt;mins, entry-&gt;secs);
00823     <span class="keywordflow">if</span> (entry-&gt;type==ST_FILE)
00824         printf(<span class="stringliteral">"%8ld "</span>,entry-&gt;size);
00825     <span class="keywordflow">else</span>
00826         printf(<span class="stringliteral">"         "</span>);
00827     <span class="keywordflow">if</span> (entry-&gt;type==ST_FILE || entry-&gt;type==ST_DIR)
00828         printf(<span class="stringliteral">"%-s "</span>,adfAccess2String(entry-&gt;access));
00829     <span class="keywordflow">if</span> (entry-&gt;comment!=NULL)
00830         printf(<span class="stringliteral">"%s "</span>,entry-&gt;comment);
00831     putchar(<span class="charliteral">'\n'</span>);
00832 }
00833 
00834 
00835 <span class="comment">/*</span>
00836 <span class="comment"> * adfCreateDir</span>
00837 <span class="comment"> *</span>
00838 <span class="comment"> */</span>
00839 RETCODE adfCreateDir(<span class="keyword">struct</span> Volume* vol, SECTNUM nParent, <span class="keywordtype">char</span>* name)
00840 {
00841     SECTNUM nSect;
00842     <span class="keyword">struct </span>bDirBlock dir;
00843     <span class="keyword">struct </span>bEntryBlock parent;
00844 
00845     <span class="keywordflow">if</span> (adfReadEntryBlock(vol, nParent, &amp;parent)!=RC_OK)
00846         <span class="keywordflow">return</span> RC_ERROR;
00847 
00848     <span class="comment">/* -1 : do not use a specific, already allocated sector */</span>
00849     nSect = adfCreateEntry(vol, &amp;parent, name, -1);
00850     <span class="keywordflow">if</span> (nSect==-1) {
00851         (*adfEnv.wFct)(<span class="stringliteral">"adfCreateDir : no sector available"</span>);
00852         <span class="keywordflow">return</span> RC_ERROR;
00853     }
00854     memset(&amp;dir, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bDirBlock));
00855     dir.nameLen = min(MAXNAMELEN, strlen(name));
00856     memcpy(dir.dirName,name,dir.nameLen);
00857     dir.headerKey = nSect;
00858 
00859     <span class="keywordflow">if</span> (parent.secType==ST_ROOT)
00860         dir.parent = vol-&gt;rootBlock;
00861     <span class="keywordflow">else</span>
00862         dir.parent = parent.headerKey;
00863     adfTime2AmigaTime(adfGiveCurrentTime(),&amp;(dir.days),&amp;(dir.mins),&amp;(dir.ticks));
00864 
00865     <span class="keywordflow">if</span> (isDIRCACHE(vol-&gt;dosType)) {
00866         <span class="comment">/* for adfCreateEmptyCache, will be added by adfWriteDirBlock */</span>
00867         dir.secType = ST_DIR;
00868         adfAddInCache(vol, &amp;parent, (<span class="keyword">struct</span> bEntryBlock *)&amp;dir);
00869         adfCreateEmptyCache(vol, (<span class="keyword">struct</span> bEntryBlock *)&amp;dir, -1);
00870     }
00871 
00872     <span class="comment">/* writes the dirblock, with the possible dircache assiocated */</span>
00873     <span class="keywordflow">if</span> (adfWriteDirBlock(vol, nSect, &amp;dir)!=RC_OK)
00874         <span class="keywordflow">return</span> RC_ERROR;
00875 
00876     adfUpdateBitmap(vol);
00877 
00878     <span class="keywordflow">if</span> (adfEnv.useNotify)
00879         (*adfEnv.notifyFct)(nParent,ST_DIR);
00880 
00881     <span class="keywordflow">return</span> RC_OK;
00882 }
00883 
00884 
00885 <span class="comment">/*</span>
00886 <span class="comment"> * adfCreateFile</span>
00887 <span class="comment"> *</span>
00888 <span class="comment"> */</span>
00889 RETCODE adfCreateFile(<span class="keyword">struct</span> Volume* vol, SECTNUM nParent, <span class="keywordtype">char</span> *name,
00890     <span class="keyword">struct</span> bFileHeaderBlock *fhdr)
00891 {
00892     SECTNUM nSect;
00893     <span class="keyword">struct </span>bEntryBlock parent;
00894 <span class="comment">/*puts("adfCreateFile in");*/</span>
00895     <span class="keywordflow">if</span> (adfReadEntryBlock(vol, nParent, &amp;parent)!=RC_OK)
00896         <span class="keywordflow">return</span> RC_ERROR;
00897 
00898     <span class="comment">/* -1 : do not use a specific, already allocated sector */</span>
00899     nSect = adfCreateEntry(vol, &amp;parent, name, -1);
00900     <span class="keywordflow">if</span> (nSect==-1) <span class="keywordflow">return</span> RC_ERROR;
00901 <span class="comment">/*printf("new fhdr=%d\n",nSect);*/</span>
00902     memset(fhdr,0,512);
00903     fhdr-&gt;nameLen = min(MAXNAMELEN, strlen(name));
00904     memcpy(fhdr-&gt;fileName,name,fhdr-&gt;nameLen);
00905     fhdr-&gt;headerKey = nSect;
00906     <span class="keywordflow">if</span> (parent.secType==ST_ROOT)
00907         fhdr-&gt;parent = vol-&gt;rootBlock;
00908     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parent.secType==ST_DIR)
00909         fhdr-&gt;parent = parent.headerKey;
00910     <span class="keywordflow">else</span>
00911         (*adfEnv.wFct)(<span class="stringliteral">"adfCreateFile : unknown parent secType"</span>);
00912     adfTime2AmigaTime(adfGiveCurrentTime(),
00913         &amp;(fhdr-&gt;days),&amp;(fhdr-&gt;mins),&amp;(fhdr-&gt;ticks));
00914 
00915     <span class="keywordflow">if</span> (adfWriteFileHdrBlock(vol,nSect,fhdr)!=RC_OK)
00916         <span class="keywordflow">return</span> RC_ERROR;
00917 
00918     <span class="keywordflow">if</span> (isDIRCACHE(vol-&gt;dosType))
00919         adfAddInCache(vol, &amp;parent, (<span class="keyword">struct</span> bEntryBlock *)fhdr);
00920 
00921     adfUpdateBitmap(vol);
00922 
00923     <span class="keywordflow">if</span> (adfEnv.useNotify)
00924         (*adfEnv.notifyFct)(nParent,ST_FILE);
00925 
00926     <span class="keywordflow">return</span> RC_OK;
00927 }
00928 
00929 
00930 <span class="comment">/*</span>
00931 <span class="comment"> * adfReadEntryBlock</span>
00932 <span class="comment"> *</span>
00933 <span class="comment"> */</span>
00934 RETCODE adfReadEntryBlock(<span class="keyword">struct</span> Volume* vol, SECTNUM nSect, <span class="keyword">struct</span> bEntryBlock *ent)
00935 {
00936     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[512];
00937 
00938     <span class="keywordflow">if</span> (adfReadBlock(vol, nSect, buf)!=RC_OK)
00939         <span class="keywordflow">return</span> RC_ERROR;
00940 
00941     memcpy(ent, buf, 512);
00942 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
00943 <span class="preprocessor"></span>    swapEndian((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)ent, SWBL_ENTRY);
00944 <span class="preprocessor">#endif</span>
00945 <span class="preprocessor"></span><span class="comment">/*printf("readentry=%d\n",nSect);*/</span>
00946     <span class="keywordflow">if</span> (ent-&gt;checkSum!=adfNormalSum((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)buf,20,512)) {
00947         (*adfEnv.wFct)(<span class="stringliteral">"adfReadEntryBlock : invalid checksum"</span>);
00948         <span class="keywordflow">return</span> RC_ERROR;
00949     }
00950     <span class="keywordflow">if</span> (ent-&gt;type!=T_HEADER) {
00951         (*adfEnv.wFct)(<span class="stringliteral">"adfReadEntryBlock : T_HEADER id not found"</span>);
00952         <span class="keywordflow">return</span> RC_ERROR;
00953     }
00954     <span class="keywordflow">if</span> (ent-&gt;nameLen&lt;0 || ent-&gt;nameLen&gt;MAXNAMELEN || ent-&gt;commLen&gt;MAXCMMTLEN) {
00955         (*adfEnv.wFct)(<span class="stringliteral">"adfReadEntryBlock : nameLen or commLen incorrect"</span>); 
00956         printf(<span class="stringliteral">"nameLen=%d, commLen=%d, name=%s sector%ld\n"</span>,
00957             ent-&gt;nameLen,ent-&gt;commLen,ent-&gt;name, ent-&gt;headerKey);
00958     }
00959 
00960     <span class="keywordflow">return</span> RC_OK;
00961 }
00962 
00963 
00964 <span class="comment">/*</span>
00965 <span class="comment"> * adfWriteEntryBlock</span>
00966 <span class="comment"> *</span>
00967 <span class="comment"> */</span>
00968 RETCODE adfWriteEntryBlock(<span class="keyword">struct</span> Volume* vol, SECTNUM nSect, <span class="keyword">struct</span> bEntryBlock *ent)
00969 {
00970     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[512];
00971     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> newSum;
00972    
00973 
00974     memcpy(buf, ent, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bEntryBlock));
00975 
00976 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
00977 <span class="preprocessor"></span>    swapEndian(buf, SWBL_ENTRY);
00978 <span class="preprocessor">#endif</span>
00979 <span class="preprocessor"></span>    newSum = adfNormalSum(buf,20,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> bEntryBlock));
00980     swLong(buf+20, newSum);
00981 
00982     <span class="keywordflow">if</span> (adfWriteBlock(vol, nSect, buf)!=RC_OK)
00983         <span class="keywordflow">return</span> RC_ERROR;
00984 
00985     <span class="keywordflow">return</span> RC_OK;
00986 }
00987 
00988 
00989 <span class="comment">/*</span>
00990 <span class="comment"> * adfWriteDirBlock</span>
00991 <span class="comment"> *</span>
00992 <span class="comment"> */</span>
00993 RETCODE adfWriteDirBlock(<span class="keyword">struct</span> Volume* vol, SECTNUM nSect, <span class="keyword">struct</span> bDirBlock *dir)
00994 {
00995     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[512];
00996     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> newSum;
00997     
00998 
00999 <span class="comment">/*printf("wdirblk=%d\n",nSect);*/</span>
01000     dir-&gt;type = T_HEADER;
01001     dir-&gt;highSeq = 0;
01002     dir-&gt;hashTableSize = 0;
01003     dir-&gt;secType = ST_DIR;
01004 
01005     memcpy(buf, dir, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bDirBlock));
01006 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
01007 <span class="preprocessor"></span>    swapEndian(buf, SWBL_DIR);
01008 <span class="preprocessor">#endif</span>
01009 <span class="preprocessor"></span>    newSum = adfNormalSum(buf,20,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> bDirBlock));
01010     swLong(buf+20, newSum);
01011 
01012     <span class="keywordflow">if</span> (adfWriteBlock(vol, nSect, buf)!=RC_OK)
01013         <span class="keywordflow">return</span> RC_ERROR;
01014 
01015     <span class="keywordflow">return</span> RC_OK;
01016 }
01017 
01018 
01019 
01020 <span class="comment">/*###########################################################################*/</span>
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:38 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
